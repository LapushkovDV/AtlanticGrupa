/*
 ╔═══════════════════════════════════════════════════════════════════════════╗
 ║                     (c) 1994, 2003 корпорация ГАЛАКТИКА                   ║
 ║ Проект        : ГАЛАКТИКА - Контур логистики                              ║
 ║ Версия        : 7.1x                                                      ║
 ║ Назначение    : Пересчет сальдовых остатков в разрезе объектов            ║
 ║                 целевого назначения запасов МТР                           ║
 ║ Ответственный : Окуневич Руслан Васильевич (RusLAN)                       ║
 ║ Параметры     : есть                                                      ║
 ╚═══════════════════════════════════════════════════════════════════════════╝
1. Из меню капстроя вызывается для пересчета сальдовых остатков (pwDoc = 0).
2. С помощью RunInterface (pwDoc = coSpOrder) вызывается:
     a) из ModifSal.vpp.
     b) в функциях DelSaldoMtr и AddSaldoMtr (ModSaldoMtr.vpp), которые используются в:
        MakePrih.vpp, MkrFun.vpp, OrdGen.vpp, Prih_Ord.vip, RashOrd.vip и zPrihOrd.vip.
3. Из MtrAct.vip вызывается public-функция MakeMtrMove.
*/

#ifdef __SALDO_MTR__

#include oEdIzm.vih
#include MtrCount.vih
#include ModifErr.vih   // Формирование сообщения об ошибке модификации таблиц
#include SaldTune.vih   // Настройка объектов учета целевого назначения запасов МТР
#include SaldoMtr.vih   // Коррекция сальдовых остатков
#include GetKau.vih     // Обьектный интерфес выбора КАУ
#include Contexts.vih

!--------------------------------------------------------------------------
#define _CurInt VipMtrCount
Interface VipMtrCount 'Параметры пересчета сальдовых остатков' EscClose, Gray;
  Show at (,4,57,14);
!--------------------------------------------------------------------------
#include oEdIzm.var
#include ServKau.vih
!--------------------------------------------------------------------------
Const
! Константы режимов вызова интерфейса (pwDoc)
  ciCount = 0; // Меню "Пересчет сальдовых остатков ..."
  ciOrder = 1; // Вызывается при коррекции аналитик складского ордера
  ciSopr  = 2; // Вызывается при коррекции аналитик акта ИЦНЗ (изменения целевого назначения запасов МТР)
! Константы результата модификации DocsKau
  ciIns = 1;
  ciUpd = 2;
  ciDel = 3;
! Константы режимов коррекции сальдовых остатков
  cbIns = false;
  cbDel = true;
! Нулевая дата
  cgdEmpty : date = date(0, 0, 0);
End;
!--------------------------------------------------------------------------
#include GetKau.var     // Переменная типа интерфейс GetKau
Var
  oTune  : VipSaldTune; // Настройка объектов учета целевого назначения запасов МТР
  oSaldo : VipSaldoMtr; // Коррекция сальдовых остатков
  vcFltr : array[0..4] of comp;
  vlQnt  : array[0..4] of longint;
!--------------------------------------------------------------------------
 Function GetFltrName(aiNum : integer) : string; forward;
!--------------------------------------------------------------------------
Create view
Var
  pwDoc : word;
  pcDoc : comp;
  pwDir : word;    // 0 - приход, 1 - расход
  pbDel : boolean; // true - при удалении позиции спецификации документа
  vdDoc : date;
  vcMC  : comp;
  vcPod : comp;
  vcMol : comp;
  vcPar : comp;
  vcObj : comp;
  vcZtr : comp;
  vcCO  : comp;

  vdStart : date;
  viType  : word;

  vbOldSaldo : boolean;
  vcSaldTune : comp;
  vlTotOper, vlTotOrd, vlTotSop, vlIns, vlUpd, vlDel, vlBadRef : longint;
  vsRole1, vsRole2, vsRole3, vsRole4 : string;

  (
      vsFltrMC
    , vsFilter1
    , vsFilter2
    , vsFilter3
    , vsFilter4
  )
As select
! vsFltrMC
    if(vlQnt[0] = longint(0), '', if(vlQnt[0] = longint(1), KatMC.Name, 'выбрано: ' + string(vlQnt[0])))
! vsFilter1..3
  , GetFltrName(1)
  , GetFltrName(2)
  , GetFltrName(3)
  , GetFltrName(4)
From
    SpOrder
  , MtrAct
  , SpMtrAct
  , SpecZatr
  , SpSopr
  , KatSopr
  , SpStep
  , StepDoc
  , BaseDoc
  , DocsKau
  , DocsKau DocsKau1
  , Pick
  , KatMC
  , KatPodr
  , KatMol
  , KatParty
  , AddSumTune
  , SaldoRaz
  , SaldoObj
  , FPCO
  , SaldTune
  , SaldTune SaldTune1
#ifdef __SMETA__
  , SpDocSmeta
#end
  , KatStroy

Where ((
! Статя затрат позиции спецификации ордера
      SpOrder.nRec == SpecZatr.cSpec
  and coSpOrder    == SpecZatr.coTable
! ЦО позиции спецификации ордера
  and SpOrder.cSpSopr  == SpSopr.nRec
  and SpSopr.cSopr     == KatSopr.nRec
  and SpSopr.cSpStep   == SpStep.nRec
#ifdef __SMETA__
! Смета позиции спецификации ордера
  and coSpOrder        == SpDocSmeta.coTable
  and SpOrder.nRec     == SpDocSmeta.cSpec
#end
  and SpStep.cStepDoc  == StepDoc.nRec
  and StepDoc.cBaseDoc == BaseDoc.nRec
! Аналитики целевого назначения позиции спецификации документа
  and pwDoc      == DocsKau.wDoc
  and pwDir      == DocsKau.wDir
  and pcDoc      == DocsKau.cDoc
  and vcSaldTune == DocsKau.cSaldTune(NoIndex)
!-------------------------------------------
  and SpMtrAct.cSopr == MtrAct.nRec
!-------------------------------------------
  and word(7)   == Pick.wList
  and vcFltr[0] == KatMC.nRec
  and word(3)   == AddSumTune.Tip
))
!-------------------------------------------
Bounds OnOrder
      pcDoc     == SpOrder.nRec

Bounds OnMC1
      word(0)   == SpOrder.SP
  and Pick.cRec == SpOrder.cMC
  and vdStart  <<= SpOrder.dOrd

Bounds OnAll1
      vdStart <<= SpOrder.dOrd
  and  (word(0) = SpOrder.SP)
!-------------------------------------------
Bounds OnMC2
  word(cgDoc_0613) == SpMtrAct.VidSopr
  and Pick.cRec    == SpMtrAct.cMc
  and vdStart     <<= SpMtrAct.dOpr

Bounds OnAll2
  word(cgDoc_0613) == SpMtrAct.VidSopr
  and vdStart     <<= SpMtrAct.dOpr
;

Parameters pwDoc, pcDoc, pwDir, pbDel;

!▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
#include ModifErr.vpp // Формирование сообщения об ошибке модификации таблиц
#include ShowKau.vpp  // Макроопределения для высветки КАУ, выбора КАУ

Screen scParam ('',hcUKSPerechSaldOstat, sci13EnEsc);
Show at (,,,);
Table KatMC;
  Bevel b1 {3, 5, 53, 8};
Fields
  viType    ('Тип пересчета: с заданной даты или с первого некорректного сальдо',, sci1EnEsc) : NoProtect;
  vdStart   ('Пересчитать сальдовые остатки начиная с даты',, sci1EnEsc) : ['DD/MM/YYYY'], NoProtect;
  vsFltrMC  ('Фильтр по МЦ',,) : Protect, QuickChoice;
!  vsRole1 : Skip;  vsFilter1 ('',,) : Protect;
!  vsRole2 : Skip;  vsFilter2 ('',,) : Protect;
!  vsRole3 : Skip;  vsFilter3 ('',,) : Protect;
!  vsRole4 : Skip;  vsFilter4 ('',,) : Protect;
Buttons
  cmYes, default,, 'Выполнить пересчет',, sci1EnEsc;
  cmCancel,,, 'Отмена',, sci1EnEsc;
<<

        `Пересчитать сальдовые остатки`
           (.) по всем складским ордерам`
           (.) с заданной даты`        .@@@@@@@@@@

     Фильтр
   `МЦ:`.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

            <. Выполнить .>     <.  Отменить .>
>>
End; //screen
/*
    .@@@@@@@@@@@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@
    .@@@@@@@@@@@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@
    .@@@@@@@@@@@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@
    .@@@@@@@@@@@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@
*/
!--------------------------------------------------------------------------
! Значение заданной аналитики
!--------------------------------------------------------------------------
Function GetFltrName(aiNum : integer) : string;
{
  case vlQnt[aiNum] of
    0 : GetFltrName := '';
    1 : GetFltrName := #ShowKauAk(cgAkOther, oTune.GetGrKau(aiNum), vcFltr[aiNum]);
   else GetFltrName := 'выбрано: ' + string(vlQnt[aiNum]);
  end;
}
!--------------------------------------------------------------------------
! Ссылка на заданную аналитику в DocsKau
!--------------------------------------------------------------------------
Function GetDocsKau(aiNum : integer) : comp;
{
  GetDocsKau := 0;
  if (aiNum > 0) and (aiNum <= 4)
    if (aiNum = 1)
      GetDocsKau := DocsKau.cObj;
    else
      GetDocsKau := DocsKau.cKau[aiNum - 1];
}
!--------------------------------------------------------------------------
! Инициализация ссылки на заданную аналитику в DocsKau
!--------------------------------------------------------------------------
Procedure SetDocsKau(aiNum : integer; acKau : comp);
{
  if (aiNum > 0) and (aiNum <= 4)
    if (aiNum = 1)
      DocsKau.cObj := acKau;
    else
      DocsKau.cKau[aiNum - 1] := acKau;
}
!--------------------------------------------------------------------------
! Ссылка на заданную аналитику в акте ИЦНЗ
!--------------------------------------------------------------------------
Function GetMtrKau(aiNum : integer) : comp;
{
  GetMtrKau := 0;
  if (aiNum > 0) and (aiNum <= 4)
    if (pwDir = 1) // аналитика источника (операция расхода)
      if (aiNum = 1)
        GetMtrKau := MtrAct.cObjSrc;
      else
        GetMtrKau := MtrAct.cKauSrc[aiNum - 1];
    else           // аналитика приемника (операция прихода)
      if (aiNum = 1)
        GetMtrKau := MtrAct.cObjDst;
      else
        GetMtrKau := MtrAct.cKauDst[aiNum - 1];
}
!--------------------------------------------------------------------------
! Ссылка на аналитику заданного типа в акте ИЦНЗ
!--------------------------------------------------------------------------
Function GetActKau(awKau : word) : comp;
{
  GetActKau := 0;
  var i : integer;
  for(i := 1; i <= oTune.KauQnt; inc(i))
    if (oTune.GetGrKau(i) = awKau)
    {
      GetActKau := GetMtrKau(i);
      break;
    }
}
!--------------------------------------------------------------------------
! Получение ссылки на другие аналитики
!--------------------------------------------------------------------------
Function GetDop(awKau : word) : comp;
{
  GetDop := 0;
  case pwDoc of
    coSpOrder  : GetDop := 0;
    coSpMtrAct : GetDop := GetActKau(awKau);
  end;
}
#ifdef __SMETA__
!--------------------------------------------------------------------------
! Получение ссылки на смету
!--------------------------------------------------------------------------
Function GetSmeta : comp;
{
  GetSmeta := 0;
  case pwDoc of
    coSpOrder :
      if (GetFirst FastFirstRow SpDocSmeta = tsOk)
        GetSmeta := SpDocSmeta.cSmeta;
    coSpMtrAct :
      GetSmeta := GetActKau(cgKau_SmetaStroy);
  end;
}
#end
!--------------------------------------------------------------------------
! Получение ссылки на объект строительства
!--------------------------------------------------------------------------
Function GetObj : comp;
{
  GetObj := 0;
  case pwDoc of
    coSpOrder  : GetObj := SpOrder.cObj;
    coSpMtrAct : GetObj := GetActKau(cgKau_ObjBuild);
  end;
}
!--------------------------------------------------------------------------
! Получение ссылки на статью затрат
!--------------------------------------------------------------------------
Function GetZtr : comp;
{
  GetZtr := AddSumTune.nRec; // Прочие
  case pwDoc of
    coSpOrder : if GetFirst FastFirstRow SpecZatr = tsOk
                  GetZtr := SpecZatr.cAddSumTune;
    coSpMtrAct  : GetZtr := GetActKau(cgKau_StZatr);
  end;
}
!--------------------------------------------------------------------------
! Получение ссылки на центр ответственности
!--------------------------------------------------------------------------
Function GetCO : comp;
{
  GetCO := 0;
  case pwDoc of
    coSpOrder : if GetFirst FastFirstRow SpSopr = tsOk
                  if oTune.CoBySopr
                  {
                    if GetFirst FastFirstRow KatSopr = tsOk
                      if GetFirst FastFirstRow FPCO where ((KatSopr.cOtvPodr == FPCO.nRec)) = tsOk
                        GetCO := KatSopr.cOtvPodr;
                  }
                  else
                  {
                    if GetFirst FastFirstRow SpStep = tsOk
                      if GetFirst FastFirstRow StepDoc = tsOk
                        if GetFirst FastFirstRow BaseDoc = tsOk
                          if GetFirst FastFirstRow FPCO where ((BaseDoc.cOtvPodr == FPCO.nRec)) = tsOk
                            GetCO := BaseDoc.cOtvPodr;
                  }
    coSpMtrAct : GetCO := GetActKau(cgKau_FpCO);
  end;
}
!--------------------------------------------------------------------------
! Является ли заданная аналитика вводимой в спецификации документа (предопределенной)
!--------------------------------------------------------------------------
Function PreDefValue(aiNum : integer) : boolean;
{
  PreDefValue := false;
  var fcKau, vcDop, vcSmeta : comp;
  var vwKau : word;
  fcKau := GetDocsKau(aiNum);
  vwKau := oTune.GetGrKau(aiNum);
  case vwKau of
    cgKau_ObjBuild :
    {
      vcObj := GetObj;
      if (fcKau <> vcObj)
      {
        SetDocsKau(aiNum, vcObj);
        PreDefValue := true;
      }
    }
    cgKau_StZatr :
    {
      vcZtr := GetZtr;
      if (fcKau <> vcZtr)
      {
        SetDocsKau(aiNum, vcZtr);
        PreDefValue := true;
      }
    }
    cgKau_FpCO :
    {
      vcCO := GetCO;
      if (fcKau <> vcCO)
      {
        SetDocsKau(aiNum, vcCO);
        PreDefValue := true;
      }
    }
#ifdef __SMETA__
    cgKau_SmetaStroy :
    {
      vcSmeta := GetSmeta;
      if (fcKau <> vcSmeta)
      {
        SetDocsKau(aiNum, vcSmeta);
        PreDefValue := true;
      }
    }
#end
    else
    {
      vcDop := GetDop(vwKau);
      if (fcKau <> vcDop)
      {
        SetDocsKau(aiNum, vcDop);
        PreDefValue := true;
      }
    }
  end;
}
!--------------------------------------------------------------------------
! Проверка возможности сохранения изменений
!--------------------------------------------------------------------------
Function CanChange : boolean;
{
  CanChange := false;
  var i : integer;
  for(i := 1; i <= oTune.KauQnt; inc(i))
    if (oTune.GetGrKau(i) = 0)
      break;
    else
      if (GetDocsKau(i) <> 0)
      {
        CanChange := true;
        break;
      }
  if CanChange and (GetDocsKau(1) = 0)
    CanChange := false;
}
!--------------------------------------------------------------------------
! Инициализация ссылок на складской разрез хранения
!--------------------------------------------------------------------------
Procedure SetDefDocsKau;
{
  DocsKau.wDoc   := pwDoc;
  DocsKau.wDir   := pwDir;
  DocsKau.cDoc   := pcDoc;
  DocsKau.dOper  := vdDoc;
  DocsKau.cMC    := vcMC;
  DocsKau.cPodr  := vcPod;
  DocsKau.cMol   := vcMol;
  DocsKau.cParty := vcPar;
}
!--------------------------------------------------------------------------
! Коррекция сальдовых остатков
!--------------------------------------------------------------------------
Procedure CorrectSaldo(abModSaldo, abDel : boolean);
{
  if abModSaldo
  {
    if not isValid(#DocsKau)
      DocsKau.nRec := 0;
    case pwDoc of
      coSpOrder  : oSaldo.CorrectBySpOrder(abDel,  TSpOrder(SpOrder.Buffer),  TDocsKau(DocsKau.Buffer));
      coSpMtrAct : oSaldo.CorrectBySpMtrAct(abDel, TSpMtrAct(SpMtrAct.Buffer), TDocsKau(DocsKau.Buffer));
    end;
  }
}
!--------------------------------------------------------------------------
! Вставка записи в таблицу аналитик целевого назначения документа
!--------------------------------------------------------------------------
Function InsertDocsKau(abModSaldo : boolean) : integer;
{
  InsertDocsKau := 0;
  if CanChange
    if __ins((insert current DocsKau), 'DocsKau', 'InsertDocsKau')
    {//    message(DocsKau.cKau[1]);
      InsertDocsKau := ciIns;
      CorrectSaldo(abModSaldo, cbIns);
    }
}
!--------------------------------------------------------------------------
! Изменение/удаление записи в таблице аналитик целевого назначения документа
!--------------------------------------------------------------------------
Function UpdateDocsKau(abModSaldo : boolean) : integer;
{
  UpdateDocsKau := 0;
  if CanChange and not pbDel
  {
    CorrectSaldo(abModSaldo, cbDel);
    if __upd((update current DocsKau), 'DocsKau', 'UpdateDocsKau')
    {
      UpdateDocsKau := ciUpd;
      CorrectSaldo(abModSaldo, cbIns);
    }
  }
  else
  {
    CorrectSaldo(abModSaldo, cbDel);
    if __del((delete current DocsKau), 'DocsKau', 'UpdateDocsKau')
      UpdateDocsKau := ciDel;
  }
}
!--------------------------------------------------------------------------
! Изменение ссылки на настройку объектов учета целевого назначения
!--------------------------------------------------------------------------
Procedure SetSaldTune;
{
  DocsKau.cSaldTune := vcSaldTune;
  var i : integer;
  for(i := 1; i <= oTune.KauQnt; inc(i))
    PreDefValue(i);
  while (i <= 4)
  {
    if (GetDocsKau(i) <> 0)
      SetDocsKau(i, 0);
    inc(i);
  }
}
!--------------------------------------------------------------------------
! Проверка актуальности ссылок на аналитики разреза
!--------------------------------------------------------------------------
Function CheckSaldTune : boolean;
{
  CheckSaldTune := false;
/*  if (vcSaldTune <> DocsKau.cSaldTune)
  {
    DocsKau.cSaldTune := vcSaldTune;
    DocsKau.cObj      := 0;
    DocsKau.cKau[1]   := 0;
    DocsKau.cKau[2]   := 0;
    DocsKau.cKau[3]   := 0;
  }*/
  var fbDelAct : boolean;
  fbDelAct := false;
  if (pwDoc = coSpMtrAct)
    if isValid(#MtrAct)
      fbDelAct := (MtrAct.Status = 0);
  if pbDel or fbDelAct
    CheckSaldTune := true; // Чтобы скорректировать сальдовые остатки
  else
  {
    var i : integer;  i := 1;
    while (i <= oTune.KauQnt)
    {
      if PreDefValue(i)
        CheckSaldTune := true;
      inc(i);
    }
    while (i <= 4)
    {
      if (GetDocsKau(i) <> 0)
      {
        SetDocsKau(i, 0);
        CheckSaldTune := true;
      }
      inc(i);
    }
  }
}
!--------------------------------------------------------------------------
! Проверяем корректность разреза хранения
!--------------------------------------------------------------------------
Function CheckSaldo(abModSaldo : boolean) : integer;
{
  CheckSaldo := 0;
  // Проверяем корректность разреза хранения
  // abModSaldo = true - корректировать сальдо только если модифицируется DocsKau,
  //   иначе выполняется пересчет остатков, т.е. сначала проверяем корректность
  //   DocsKau, а потом добавяем операцию движения в сальдовые остатки
  if GetFirst FastFirstRow DocsKau = tsOk
  {
    if CheckSaldTune
      CheckSaldo := UpdateDocsKau(abModSaldo);
  }
  else
  {
    ClearBuffer(#DocsKau);
    SetDefDocsKau;
    SetSaldTune;          //message(docskau.ckau[1]);
    CheckSaldo := InsertDocsKau(abModSaldo);
  }
  case CheckSaldo of
    ciIns : inc(vlIns);
    ciUpd : inc(vlUpd);
    ciDel : inc(vlDel);
  end;
  if not abModSaldo
    CorrectSaldo(true, cbIns);
}
!--------------------------------------------------------------------------
! Инициализация параметров по текущему складскому ордеру
!--------------------------------------------------------------------------
Procedure CheckThisSpOrder(abModSaldo : boolean);
{
  if vbOldSaldo
  { // Для старой версии хранения сразу корректируем сальдовые остатки
    DocsKau.nRec := 0;
    oSaldo.CorrectBySpOrder(pbDel, TSpOrder(SpOrder.Buffer), TDocsKau(DocsKau.Buffer));
  }
  else
  {
    pwDoc := coSpOrder;
    pcDoc := SpOrder.nRec;
    vdDoc := SpOrder.dOrd;
    vcMC  := SpOrder.cMC;
    vcPod := SpOrder.ccPodr;
    vcMol := SpOrder.ccMol;
    vcPar := SpOrder.cParty;
    pwDir := SpOrder.VidOrder;
    CheckSaldo(abModSaldo);
  }
}
!--------------------------------------------------------------------------
! Инициализация параметров по текущему акту ИЦНЗ
!--------------------------------------------------------------------------
Procedure CheckThisSpMtrAct(abModSaldo : boolean; awDir : word); //; adForm : date);
{
  if vbOldSaldo
  { // Для старой версии хранения сразу корректируем сальдовые остатки
    oSaldo.CorrectBySpMtrAct_Old(pbDel, true,  TSpMtrAct(SpMtrAct.Buffer), TMtrAct(MtrAct.Buffer));
    oSaldo.CorrectBySpMtrAct_Old(pbDel, false, TSpMtrAct(SpMtrAct.Buffer), TMtrAct(MtrAct.Buffer));
  }
  else
  {
    pwDoc := coSpMtrAct;
    pcDoc := SpMtrAct.nRec;
    vdDoc := MtrAct.dOpr;
    vcMC  := SpMtrAct.cMc;
    vcPod := SpMtrAct.cPodr;
    vcMol := SpMtrAct.cMol;
    vcPar := SpMtrAct.cParty;
    pwDir := awDir; // расход
    CheckSaldo(abModSaldo);
!    pwDir := 0; // приход
!    CheckSaldo(abModSaldo);
  }
}
!--------------------------------------------------------------------------
! Проверка аналитик разреза целевого назначения для заданного документа
!--------------------------------------------------------------------------
Procedure CheckDocsKau;
{
  abort;
  if boGetTune('Oper.Purpose')
    // Позиционируемся на документ
    case pwDoc of
      coSpOrder :
      {
        PushBounds(tbOnOrder);
        if GetFirst FastFirstRow SpOrder = tsOk
        {
          pwDir := SpOrder.VidOrder;
          CheckThisSpOrder(true);
        }
        PopBounds(tbOnOrder);
      }
    end;
}
!--------------------------------------------------------------------------
! Удаление операции движения из сальдовых остатков
!--------------------------------------------------------------------------
!Procedure DelSaldo(awDoc : word; acDoc : comp);
!{
!  pwDoc := awDoc;
!  pcDoc := acDoc;
!  pbDel := true;
!  CheckDocsKau;
!}
!--------------------------------------------------------------------------
! Добавление операции движения в сальдовые остатки
!--------------------------------------------------------------------------
!Procedure AddSaldo(awDoc : word; acDoc : comp);
!{
!  pwDoc := awDoc;
!  pcDoc := acDoc;
!  pbDel := false;
!  CheckDocsKau;
!}
!--------------------------------------------------------------------------
! Ссылка на заданную аналитику в DocsKau
!--------------------------------------------------------------------------
Function GetOrderKau(aiNum : integer) : comp;
{
  GetOrderKau := 0;
  if isValid(#DocsKau)
    GetOrderKau := GetDocsKau(aiNum);
  else
    if vbOldSaldo and (aiNum = 1)
      GetOrderKau := SpOrder.cObj;
}
!--------------------------------------------------------------------------
! Просмотр складских ордеров
!--------------------------------------------------------------------------
Function LoopOrder(asMess : string) : boolean;
{
  LoopOrder := true;
  _loop SpOrder
  {
    if not iNextVisual(asMess + 'Просмотр складских ордеров: ' + dts(SpOrder.dOrd))
    {
      LoopOrder := false;
      break;
    }
    if oSaldo.isValidRaz(0, vlQnt[1], vlQnt[2], vlQnt[3], 0, GetOrderKau(1), GetOrderKau(2), GetOrderKau(3))
    {
      inc(vlTotOrd);
      CheckThisSpOrder(false);
    }
  }
}
!--------------------------------------------------------------------------
! Просмотр актов изменения целевого назначения
!--------------------------------------------------------------------------
Function LoopSopr(asMess : string) : boolean;
{
  var i : word;
  LoopSopr := true;
  for(i := 0; i <= 1; inc(i))
    _loop SpMtrAct
      if GetFirst FastFirstRow MtrAct = tsOk
      {
        if (vcSaldTune <> if(i = 1, MtrAct.cSaldSrc, MtrAct.cSaldDst))
          Continue;
        if not iNextVisual(asMess + 'Просмотр актов изменения целевого назначения: ' + dts(SpMtrAct.dSopr))
        {
          LoopSopr := false;
          break;
        }
        if (MtrAct.Status = 1)
          if oSaldo.isValidRaz(0, vlQnt[1], vlQnt[2], vlQnt[3], 0, GetDocsKau(1), GetDocsKau(2), GetDocsKau(3))
          {
            inc(vlTotSop);
            CheckThisSpMtrAct(false, i); //, MtrAct.dOpr);
          }
      }
}
!--------------------------------------------------------------------------
! Пересчет сальдовых остатков
!--------------------------------------------------------------------------
Function RecalcSaldoObj : boolean;
{
  RecalcSaldoObj := true;
  pbDel := false;
  StartNewVisual(vtRotateVisual, vfTimer + vfBreak + vfConfirm, '', 1);
  SetVisualTitle('Пересчет сальдовых остатков');
  oSaldo.InitFilterMarker(vcSaldTune, vlQnt[1], vlQnt[2], vlQnt[3]);
  var fsMess : string;
  fsMess := '';
  if (vlQnt[0] <> longint(0))
  {
    fsMess := 'МЦ: "' + KatMC.Name + '"'#13;
    PushBounds(tbOnMC1);
    PushBounds(tbOnMC2);
    _loop Pick
      if not LoopOrder(fsMess) or not LoopSopr(fsMess)
      {
        RecalcSaldoObj := false;
        break;
      }
    PopBounds(tbOnMC2);
    PopBounds(tbOnMC1);
  }
  else
  {
    PushBounds(tbOnAll1);
    RecalcSaldoObj := LoopOrder('');
    PopBounds(tbOnAll1);
    if RecalcSaldoObj
    {
      PushBounds(tbOnAll2);
      RecalcSaldoObj := LoopSopr('');
      PopBounds(tbOnAll2);
    }
  }
  oSaldo.DoneFilterMarker(vlQnt[1], vlQnt[2], vlQnt[3]);
  StopVisual('', 0);
}

!--------------------------------------------------------------------------
! Выбор МЦ для фильтра
!--------------------------------------------------------------------------
Procedure onPickMC;
{
  vlQnt[0] := longint(0);
  if (RunInterface('GetSomeMC', comp(-12345)) = cmDefault)
    _loop Pick
    {
      vlQnt[0] := vlQnt[0] + longint(1);
      if (vlQnt[0] = longint(1))
        vcFltr[0] := comp(Pick.cRec);
    }
  ReReadRecord(#KatMC);
}
!--------------------------------------------------------------------------
! Выбор заданной аналитики разреза целевого назначения для фильтра
!--------------------------------------------------------------------------
Procedure onPickKau(aiNum : integer);
{
  vlQnt[aiNum] := longint(iGetKau.GetCodeKau(cgiPickMult, oTune.GetGrKau(aiNum), vcFltr[aiNum]));
  ReScanPanel(#KatMC);
}
!--------------------------------------------------------------------------
! Удаление выбора МЦ для фильтра
!--------------------------------------------------------------------------
Procedure onDelMC;
{
  if (delete all Pick where (( word(7) == Pick.wList )) = tsOk)
  {
    vlQnt[0] := longint(0);
    ReScanPanel(#KatMC);
  }
}
!--------------------------------------------------------------------------
! Удаление выбора заданной аналитики разреза целевого назначения для фильтра
!--------------------------------------------------------------------------
Procedure onDelKau(aiNum : integer);
{
  vlQnt[aiNum] := longint(0);
  vcFltr[aiNum] := comp(0);
  ReScanPanel(#KatMC);
}
!--------------------------------------------------------------------------
!
!--------------------------------------------------------------------------
Procedure InitParam;
{
  vcSaldTune := oTune.GetTune(1);
  vbOldSaldo := oTune.isOldSaldo; //(vcSaldTune = 0);
}
!--------------------------------------------------------------------------
! [PUBLIC] Выполнение перераспределения МТР между разрезами объектов учета целевого назначения
!--------------------------------------------------------------------------
Procedure MakeMtrMove(abDel : boolean; adForm : date; arMtrAct : TMtrAct; arSpMtrAct : TSpMtrAct);
{
  MtrAct.Buffer   := type$MtrAct(arMtrAct);
  SpMtrAct.Buffer := type$SpMtrAct(arSpMtrAct);
  pbDel := abDel;
  if not abDel
  { // Изменяем статус акта на "исполнен", но дата и статус еще не изменены
    MtrAct.dOpr := adForm;
    MtrAct.Status := 1;
  }
  if (MtrAct.cSaldSrc <> 0)
  {
    if (GetFirst SaldTune1 where ((MtrAct.cSaldSrc == SaldTune1.nRec)) = tsOk)
    {
      vcSaldTune := oTune.GetTune(SaldTune1.wType);
      vbOldSaldo := oTune.isOldSaldo;
      CheckThisSpMtrAct(true, 1);
    }
  }
  if (MtrAct.cSaldDst <> 0)
  {
    if (GetFirst SaldTune1 where ((MtrAct.cSaldDst == SaldTune1.nRec)) = tsOk)
    {
      vcSaldTune := oTune.GetTune(SaldTune1.wType);
      vbOldSaldo := oTune.isOldSaldo;
      CheckThisSpMtrAct(true, 0);
    }
  }
}
!--------------------------------------------------------------------------
HandleEvent // Interface
!--------------------------------------------------------------------------
!cmOnVipLoad :
!  InitParam;
!--------------------------------------------------------------------------
cmInit :
{
  InitParam;
  if (pwDoc <> 0)
    // Коррекция позиции спецификации документа, заданного pwDoc и pcDoc
    CheckDocsKau;
  else if not boGetTune('Oper.Purpose')
  {
    abort;
    message('Контроль целевого назначения запасров МТР не ведется.'#13 +
            '(см. ' + GetTuneName('Oper.Purpose') + ').'#13#13 +
            'Операция отменена.', Warning);
  }
  else
  { // Пересчет сальдовых остатков
    if (GetFirst SpOrder where (( word(0) == SpOrder.SP )) <> tsOk)
    { // Акты не проверяем, т.к. их не будет при отсутствии ордеров
      abort;
      message('Нет складских ордеров и актов изменения целевого назначения запасов МТР.'#13#13 +
              'Пересчет невозможен.', Information);
    }
    else
    {
      vdStart := SpOrder.dOrd;
      viType := 0;
      ClearFieldState(#vdStart, sfVisible);
      var i : integer;
      for(i := 1; i <= oTune.KauQnt; inc(i))
        case i of
          1 : vsRole1 := oTune.GetRoleName(1);
          2 : vsRole2 := oTune.GetRoleName(2);
          3 : vsRole3 := oTune.GetRoleName(3);
          4 : vsRole4 := oTune.GetRoleName(4);
        end;
      while(i <= 4)
      {
        case i of
          2 : ClearFieldState(#vsFilter2, sfVisible);
          3 : ClearFieldState(#vsFilter3, sfVisible);
          4 : ClearFieldState(#vsFilter4, sfVisible);
        end;
        inc(i);
      }
    }
  }
}
!--------------------------------------------------------------------------
cmYes :
  if message('Произвести пересчет сальдовых остатков'#13 +
             'в разрезе объектов учета запасов МТР?',
              YesNo + mfSwapButtons + Confirmation) = cmYes
    if message('Перед пересчетом необходимо проверить целостность ордеров.'#13#13 +
               'При выполнении данной операции не должно производиться'#13 +
               'никакого движения по складам, а также должны быть закрыты'#13 +
               'все интерфейсы на Вашей машине.'#13#13 +
               'Продолжить?', YesNo + mfSwapButtons + Confirmation) = cmYes
    {
      vlTotOper := 0; vlTotOrd := 0; vlTotSop := 0;
      vlIns := 0; vlUpd := 0;  vlDel := 0; vlBadRef := 0;
      if (viType = 0)
        vdStart := cgdEmpty;
      var fbOk : boolean;
      var vlTotSt : longint;
      vlTotSt := 0;
      _Loop SaldTune
      {
        vcSaldTune := oTune.GetTune(SaldTune.wType);
        vbOldSaldo := oTune.isOldSaldo;
        oSaldo.InitIfc(SaldTune.wType);
        inc(vlTotSt);

        if (vcSaldTune <> 0)
          delete all SaldoObj where ((comp(0) == SaldoObj.cSaldTune));

        fbOk := oSaldo.DelSaldo(vcSaldTune, vlQnt[0], vlQnt[1], vlQnt[2], vlQnt[3], vdStart);

        if fbOk
          fbOk := RecalcSaldoObj;

        if (not fbOk)
          Break;

        if (SaldTune.wType = 1) // Для УКСа удаление разрезов невалидных объектов
          _Loop DocsKau1 where ((SaldTune.nRec == DocsKau1.cSaldTune))
            if (GetFirst KatStroy where ((DocsKau1.cObj == KatStroy.nRec)) <> tsOk)
            {
              delete SaldoRaz where ((SaldTune.nRec == SaldoRaz.cSaldTune and
                                      word(0)       == SaldoRaz.wMode     and
                                      DocsKau1.cObj == SaldoRaz.cObj));
              delete SaldoRaz where ((SaldTune.nRec == SaldoRaz.cSaldTune and
                                      word(1)       == SaldoRaz.wMode     and
                                      DocsKau1.cObj == SaldoRaz.cObj));
              delete SaldoRaz where ((SaldTune.nRec == SaldoRaz.cSaldTune and
                                      word(2)       == SaldoRaz.wMode     and
                                      DocsKau1.cObj == SaldoRaz.cObj));
              delete SaldoObj where ((SaldTune.nRec == SaldoObj.cSaldTune and
                                      word(0)       == SaldoObj.wMode     and
                                      DocsKau1.cObj == SaldoObj.cObj));
              delete SaldoObj where ((SaldTune.nRec == SaldoObj.cSaldTune and
                                      word(1)       == SaldoObj.wMode     and
                                      DocsKau1.cObj == SaldoObj.cObj));
              delete SaldoObj where ((SaldTune.nRec == SaldoObj.cSaldTune and
                                      word(2)       == SaldoObj.wMode     and
                                      DocsKau1.cObj == SaldoObj.cObj));

              if (delete current DocsKau1 = tsOk)
                inc(vlDel);
            }
      }
      var fsMess : string;
      fsMess := 'Пересчет сальдовых остатков МЦ в разрезе'#13 +
                'объектов учета запасов МТР (' + string(vlTotST);
      if not fbOk
        message(fsMess + 'прерван или выполнен с ошибками.'#13#13 +
                         'Сальдовые остатки не корректны.', Error);
      else
      {
        fsMess := fsMess + ') завершен успешно.'#13#13 +
                 'Обработано позиций спецификаций:'#13 +
                 '    складских ордеров: ' + string(vlTotOrd div vlTotSt);
        if (vlTotSop <> 0)
          fsMess := fsMess + ''#13 + '    актов ИЦНЗ: ' + string(vlTotSop);
        if (vlIns <> 0) or (vlUpd <> 0) or (vlDel <> 0)
          fsMess := fsMess + ''#13'Модифицированы ссылки на разрезы целевого назначения:'#13 +
                    if(vlIns <> 0, 'Добавлено: ' + string(vlIns) + ''#13, '') +
                    if(vlUpd <> 0, 'Исправлено некорректных: ' + string(vlUpd) + ''#13, '') +
                    if(vlDel <> 0, 'Удалено лишних: ' + string(vlDel), '');
        message(fsMess, Information);
      }
      CloseInterface(cmCancel);
    }
!--------------------------------------------------------------------------
cmOpenSearch :
  if (CurField = #vsFltrMC)
  {
    QuickChoiceName := 'qcNameMCUsl';
    onPickMC;
  }
!--------------------------------------------------------------------------
cmPick :
  if (CurField = #vsFltrMC)
    onPickMC;
  else
    case CurField of
      #vsFilter1 : onPickKau(1);
      #vsFilter2 : onPickKau(2);
      #vsFilter3 : onPickKau(3);
      #vsFilter4 : onPickKau(4);
    end;
!--------------------------------------------------------------------------
cmDelOnProtect :
  if (CurField = #vsFltrMC)
    onDelMC;
  else
    case CurField of
      #vsFilter1 : onDelKau(1);
      #vsFilter2 : onDelKau(2);
      #vsFilter3 : onDelKau(3);
      #vsFilter4 : onDelKau(4);
    end;

cmCheckField:
  if CurField = #viType
    if (viType = 1)
      SetFieldState(#vdStart, sfVisible);
    else
    {
      ClearFieldState(#vdStart, sfVisible);
      vdStart := SpOrder.dOrd;
    }
!--------------------------------------------------------------------------
End; // HandleEvent Interface
!--------------------------------------------------------------------------
End.
!--------------------------------------------------------------------------
#undef _CurInt // VipMtrCount
#end // __SALDO_MTR__
